<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>False Sharing ¬∑ OhMyThreads.jl</title><meta name="title" content="False Sharing ¬∑ OhMyThreads.jl"/><meta property="og:title" content="False Sharing ¬∑ OhMyThreads.jl"/><meta property="twitter:title" content="False Sharing ¬∑ OhMyThreads.jl"/><meta name="description" content="Documentation for OhMyThreads.jl."/><meta property="og:description" content="Documentation for OhMyThreads.jl."/><meta property="twitter:description" content="Documentation for OhMyThreads.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">OhMyThreads.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">OhMyThreads</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../mc/mc/">Parallel Monte Carlo</a></li><li><a class="tocitem" href="../../juliaset/juliaset/">Julia Set</a></li><li><a class="tocitem" href="../../integration/integration/">Trapezoidal Integration</a></li></ul></li><li><a class="tocitem" href="../../../translation/">Translation Guide</a></li><li><a class="tocitem" href="../../tls/tls/">Thread-Safe Storage</a></li><li class="is-active"><a class="tocitem" href>False Sharing</a><ul class="internal"><li><a class="tocitem" href="#Baseline:-sequential-summation"><span>Baseline: sequential summation</span></a></li><li><a class="tocitem" href="#The-problematic-parallel-implementation"><span>The problematic parallel implementation</span></a></li><li><a class="tocitem" href="#The-issue:-False-sharing"><span>The issue: False sharing</span></a></li><li><a class="tocitem" href="#Task-local-parallel-summation"><span>Task-local parallel summation</span></a></li><li><a class="tocitem" href="#Parallel-summation-with-OhMyThreads"><span>Parallel summation with OhMyThreads</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../refs/api/">Public API</a></li><li><a class="tocitem" href="../../../refs/experimental/">Experimental</a></li><li><a class="tocitem" href="../../../refs/internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>False Sharing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>False Sharing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaFolds2/OhMyThreads.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/master/docs/src/literate/falsesharing/falsesharing.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="FalseSharing"><a class="docs-heading-anchor" href="#FalseSharing">False Sharing</a><a id="FalseSharing-1"></a><a class="docs-heading-anchor-permalink" href="#FalseSharing" title="Permalink"></a></h1><p><em>False Sharing</em> is a very common but subtle performance issue that comes up again and again when writing parallel code manually. For this reason, we shall discuss what it is about and how to avoid it.</p><p>For simplicity, let&#39;s focus on a specific example: parallel summation.</p><h2 id="Baseline:-sequential-summation"><a class="docs-heading-anchor" href="#Baseline:-sequential-summation">Baseline: sequential summation</a><a id="Baseline:-sequential-summation-1"></a><a class="docs-heading-anchor-permalink" href="#Baseline:-sequential-summation" title="Permalink"></a></h2><p>To establish a baseline, that we can later compare against, we define some fake data, which we&#39;ll sum up, and benchmark Julia&#39;s built-in, non-parallel <code>sum</code> function.</p><pre><code class="language-julia hljs">using Base.Threads: nthreads
using BenchmarkTools

data = rand(1_000_000 * nthreads());
@btime sum($data);</code></pre><pre><code class="nohighlight hljs">  2.327 ms (0 allocations: 0 bytes)
</code></pre><h2 id="The-problematic-parallel-implementation"><a class="docs-heading-anchor" href="#The-problematic-parallel-implementation">The problematic parallel implementation</a><a id="The-problematic-parallel-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#The-problematic-parallel-implementation" title="Permalink"></a></h2><p>A conceptually simple (and valid) approach to parallelizing the summation is to divide the full computation into parts. Specifically, the idea is to divide the data into chunks, compute the partial sums of these chunks in parallel, and finally sum up the partial results. (Note that we will not concern ourselves with potential minor or catastrophic numerical errors due to potential rearrangements of terms in the summation here.)</p><p>A common, manual implementation of this idea might look like this:</p><pre><code class="language-julia hljs">using OhMyThreads: @spawn, chunks

function parallel_sum_falsesharing(data; nchunks = nthreads())
    psums = zeros(eltype(data), nchunks)
    @sync for (c, idcs) in enumerate(chunks(data; n = nchunks))
        @spawn begin
            for i in idcs
                psums[c] += data[i]
            end
        end
    end
    return sum(psums)
end</code></pre><pre><code class="nohighlight hljs">parallel_sum_falsesharing (generic function with 1 method)</code></pre><p>The code is pretty straightforward: We allocate space for the results of the partial sums (<code>psums</code>) and, on <code>nchunks</code> many tasks, add up the data elements of each partial sum in parallel. More importantly, and in this context perhaps surprisingly, the code is also <strong>correct</strong> in the sense that it produces the desired result.</p><pre><code class="language-julia hljs">using Test
@test sum(data) ‚âà parallel_sum_falsesharing(data)</code></pre><pre><code class="nohighlight hljs">Test Passed</code></pre><p>This is just a reflection of the fact that there is no logical sharing of data - because each parallel tasks modifies a different element of <code>psums</code> - implying the absence of race conditions.</p><p>What&#39;s the issue then?! Well, the sole purpose of parallelization is to reduce runtime. So let&#39;s see how well we&#39;re doing in this respect.</p><pre><code class="language-julia hljs">nthreads()</code></pre><pre><code class="nohighlight hljs">10</code></pre><pre><code class="language-julia hljs">@btime parallel_sum_falsesharing($data);</code></pre><pre><code class="nohighlight hljs">  52.919 ms (221 allocations: 18.47 KiB)
</code></pre><p>A (huge) <strong>slowdown</strong>?! Clearly, that&#39;s the opposite of what we tried to achieve!</p><h2 id="The-issue:-False-sharing"><a class="docs-heading-anchor" href="#The-issue:-False-sharing">The issue: False sharing</a><a id="The-issue:-False-sharing-1"></a><a class="docs-heading-anchor-permalink" href="#The-issue:-False-sharing" title="Permalink"></a></h2><p>Although our parallel summation above is semantically correct, it has a big <strong>performance issue</strong>: <em>False sharing</em>. To understand false sharing, we have to think a little bit about how computers work. Specifically, we need to realize that processors cache memory in lines (rather than individual elements) and that caches of different processors are kept coherent. When two (or more) different CPU cores operate on independent data elements that <strong>fall into the same cache line</strong> (i.e. they are part of the same memory address region) the <strong>cache coherency mechanism leads to costly synchronization</strong> between cores.</p><p>In our case, this happens despite the fact that different parallel tasks (on different CPU cores) <em>logically</em> don&#39;t care about the rest of the data in the cache line at all.</p><p><img src="../false_sharing.svg" alt/></p><p>Given these insights, we can come up with a few workarounds that mitigate the issue. The most prominent is probably padding, where one simply adds sufficiently many unused zeros to <code>psums</code> such that different partial sum counters don&#39;t fall into the same cache line. However, let&#39;s discuss a more fundamental, more efficient, and more elegant solution.</p><h2 id="Task-local-parallel-summation"><a class="docs-heading-anchor" href="#Task-local-parallel-summation">Task-local parallel summation</a><a id="Task-local-parallel-summation-1"></a><a class="docs-heading-anchor-permalink" href="#Task-local-parallel-summation" title="Permalink"></a></h2><p>The key mistake in <code>parallel_sum_falsesharing</code> above is the non-local modification of (implicitly) shared state (cache lines of <code>psums</code>) very frequently (in the innermost loop). We can simply avoid this by making the code more task-local. To this end, we introduce a <strong>task-local accumulator variable</strong>, which we use to perform the task-local partial sums. Only at the very end do we communicate the result to the main thread, e.g. by writing it into <code>psums</code> (once!).</p><pre><code class="language-julia hljs">function parallel_sum_tasklocal(data; nchunks = nthreads())
    psums = zeros(eltype(data), nchunks)
    @sync for (c, idcs) in enumerate(chunks(data; n = nchunks))
        @spawn begin
            local s = zero(eltype(data))
            for i in idcs
                s += data[i]
            end
            psums[c] = s
        end
    end
    return sum(psums)
end

@test sum(data) ‚âà parallel_sum_tasklocal(data)
@btime parallel_sum_tasklocal($data);</code></pre><pre><code class="nohighlight hljs">  1.120 ms (221 allocations: 18.55 KiB)
</code></pre><p>Finally, there is a speed up! üéâ</p><p>Two comments are in order.</p><p>First, we note that the only role that <code>psums</code> plays is as a temporary storage for the results from the parallel tasks to be able to sum them up eventually. We could get rid of it entirely by using a <code>Threads.Atomic</code> instead which would get updated via <code>Threads.atomic_add!</code> from each task directly. However, for our discussion, this is a detail and we won&#39;t discuss it further.</p><p>Secondly, while keeping the general idea, we can drastically simplify the above code by using <code>map</code> and reusing the built-in (sequential) <code>sum</code> function on each parallel task:</p><pre><code class="language-julia hljs">function parallel_sum_map(data; nchunks = nthreads())
    ts = map(chunks(data, n = nchunks)) do idcs
        @spawn @views sum(data[idcs])
    end
    return sum(fetch.(ts))
end

@test sum(data) ‚âà parallel_sum_map(data)
@btime parallel_sum_map($data);</code></pre><pre><code class="nohighlight hljs">  893.396 Œºs (64 allocations: 5.72 KiB)
</code></pre><p>This implementation is conceptually clearer in that there is no explicit modification of shared state, i.e. no <code>pums[c] = s</code>, anywhere at all. We can&#39;t run into false sharing if we don&#39;t modify shared state üòâ.</p><p>Note that since we use the built-in <code>sum</code> function, which is highly optimized, we might see better runtimes due to other effects - like SIMD and the absence of bounds checks - compared to the simple for-loop accumulation in <code>parallel_sum_tasklocal</code> above.</p><h2 id="Parallel-summation-with-OhMyThreads"><a class="docs-heading-anchor" href="#Parallel-summation-with-OhMyThreads">Parallel summation with OhMyThreads</a><a id="Parallel-summation-with-OhMyThreads-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-summation-with-OhMyThreads" title="Permalink"></a></h2><p>Finally, all of the above is abstracted away for you if you simply use <a href="../../../refs/api/#OhMyThreads.treduce"><code>treduce</code></a> to implement the parallel summation. It also only takes a single line and function call.</p><pre><code class="language-julia hljs">using OhMyThreads: treduce

@test sum(data) ‚âà treduce(+, data; ntasks = nthreads())
@btime treduce($+, $data; ntasks = $nthreads());</code></pre><pre><code class="nohighlight hljs">  899.097 Œºs (68 allocations: 5.92 KiB)
</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tls/tls/">¬´ Thread-Safe Storage</a><a class="docs-footer-nextpage" href="../../../refs/api/">Public API ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 18 September 2024 09:12">Wednesday 18 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
