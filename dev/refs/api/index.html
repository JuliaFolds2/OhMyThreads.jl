<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · OhMyThreads.jl</title><meta name="title" content="Public API · OhMyThreads.jl"/><meta property="og:title" content="Public API · OhMyThreads.jl"/><meta property="twitter:title" content="Public API · OhMyThreads.jl"/><meta name="description" content="Documentation for OhMyThreads.jl."/><meta property="og:description" content="Documentation for OhMyThreads.jl."/><meta property="twitter:description" content="Documentation for OhMyThreads.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OhMyThreads.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">OhMyThreads</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../literate/mc/mc/">Parallel Monte Carlo</a></li><li><a class="tocitem" href="../../literate/juliaset/juliaset/">Julia Set</a></li><li><a class="tocitem" href="../../literate/integration/integration/">Trapezoidal Integration</a></li></ul></li><li><a class="tocitem" href="../../translation/">Translation Guide</a></li><li><a class="tocitem" href="../../literate/boxing/boxing/">Boxed Variables</a></li><li><a class="tocitem" href="../../literate/tls/tls/">Thread-Safe Storage</a></li><li><a class="tocitem" href="../../literate/falsesharing/falsesharing/">False Sharing</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Exported"><span>Exported</span></a></li><li><a class="tocitem" href="#Re-exported"><span>Re-exported</span></a></li><li><a class="tocitem" href="#Public-but-not-exported"><span>Public but not exported</span></a></li></ul></li><li><a class="tocitem" href="../experimental/">Experimental</a></li><li><a class="tocitem" href="../internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaFolds2/OhMyThreads.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/master/docs/src/refs/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">Public API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Exported"><a class="docs-heading-anchor" href="#Exported">Exported</a><a id="Exported-1"></a><a class="docs-heading-anchor-permalink" href="#Exported" title="Permalink"></a></h2><h3 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@tasks" href="#OhMyThreads.@tasks"><code>OhMyThreads.@tasks</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@tasks for ... end</code></pre><p>A macro to parallelize a <code>for</code> loop by spawning a set of tasks that can be run in parallel. The policy of how many tasks to spawn and how to distribute the iteration space among the tasks (and more) can be configured via <code>@set</code> statements in the loop body.</p><p>Supports reductions (<code>@set reducer=&lt;reducer function&gt;</code>) and collecting the results (<code>@set collect=true</code>).</p><p>Under the hood, the <code>for</code> loop is translated into corresponding parallel <a href="#OhMyThreads.tforeach"><code>tforeach</code></a>, <a href="#OhMyThreads.tmapreduce"><code>tmapreduce</code></a>, or <a href="#OhMyThreads.tmap"><code>tmap</code></a> calls.</p><p>See also: <a href="#OhMyThreads.@set"><code>@set</code></a>, <a href="#OhMyThreads.@local"><code>@local</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using OhMyThreads: @tasks</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:3
    println(i)
end</code></pre><pre><code class="language-julia hljs">@tasks for x in rand(10)
    @set reducer=+
    sin(x)
end</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:5
    @set collect=true
    i^2
end</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:100
    @set ntasks=4*nthreads()
    # non-uniform work...
end</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:5
    @set scheduler=:static
    println(&quot;i=&quot;, i, &quot; → &quot;, threadid())
end</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:100
    @set begin
        scheduler=:static
        chunksize=10
    end
    println(&quot;i=&quot;, i, &quot; → &quot;, threadid())
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/macros.jl#L1-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@set" href="#OhMyThreads.@set"><code>OhMyThreads.@set</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@set name = value</code></pre><p>This can be used inside a <code>@tasks for ... end</code> block to specify settings for the parallel execution of the loop.</p><p>Multiple settings are supported, either as separate <code>@set</code> statements or via <code>@set begin ... end</code>.</p><p><strong>Settings</strong></p><ul><li><code>reducer</code> (e.g. <code>reducer=+</code>): Indicates that a reduction should be performed with the provided binary function. See <a href="#OhMyThreads.tmapreduce"><code>tmapreduce</code></a> for more information.</li><li><code>collect</code> (e.g. <code>collect=true</code>): Indicates that results should be collected (similar to <code>map</code>).</li></ul><p>All other settings will be passed on to the underlying parallel functions (e.g. <a href="#OhMyThreads.tmapreduce">tmapreduce</a>) as keyword arguments. Hence, you may provide whatever these functions accept as keyword arguments. Among others, this includes</p><ul><li><code>scheduler</code> (e.g. <code>scheduler=:static</code>): Can be either a <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> or a <code>Symbol</code> (e.g. <code>:dynamic</code>, <code>:static</code>, <code>:serial</code>, or <code>:greedy</code>).</li><li><code>init</code> (e.g. <code>init=0.0</code>): Initial value to be used in a reduction (requires <code>reducer=...</code>).</li></ul><p>Settings like <code>ntasks</code>, <code>chunksize</code>, and <code>split</code> etc. can be used to tune the scheduling policy (if the selected scheduler supports it).</p><p>Note that the assignment is hoisted above the loop body which means that the scope is <em>not</em> the scope of the loop (even though it looks like it) but rather the scope <em>surrounding</em> the loop body. (<code>@macroexpand</code> is a useful tool to inspect the generated code of the <code>@tasks</code> block.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/macros.jl#L70-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@local" href="#OhMyThreads.@local"><code>OhMyThreads.@local</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@local name = value

@local name::T = value</code></pre><p>Can be used inside a <code>@tasks for ... end</code> block to specify <a href="../../literate/tls/tls/#TLS">task-local values</a> (TLV) via explicitly typed assignments. These values will be allocated once per task (rather than once per iteration) and can be re-used between different task-local iterations.</p><p>There can only be a single <code>@local</code> block in a <code>@tasks for ... end</code> block. To specify multiple TLVs, use <code>@local begin ... end</code>. Compared to regular assignments, there are some limitations though, e.g. TLVs can&#39;t reference each other.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using OhMyThreads: @tasks
using OhMyThreads.Tools: taskid

@tasks for i in 1:10
    @set begin
        scheduler=:dynamic
        ntasks=2
    end
    @local x = zeros(3) # TLV

    x .+= 1
    println(taskid(), &quot; -&gt; &quot;, x)
end</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:10
    @local begin
        x = rand(Int, 3)
        M = rand(3, 3)
    end
    # ...
end</code></pre><p>Task local variables created by <code>@local</code> are by default constrained to their inferred type, but if you need to, you can specify a different type during declaration:</p><pre><code class="language-julia hljs">@tasks for i in 1:10
    @local x::Vector{Float64} = some_hard_to_infer_setup_function()
    # ...
end</code></pre><p>The right hand side of the assignment is hoisted outside of the loop body and captured as a closure used to initialize the task local value. This means that the scope of the closure is <em>not</em> the scope of the loop (even though it looks like it) but rather the scope <em>surrounding</em> the loop body. (<code>@macroexpand</code> is a useful tool to inspect the generated code of the <code>@tasks</code> block.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/macros.jl#L103-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@only_one" href="#OhMyThreads.@only_one"><code>OhMyThreads.@only_one</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@only_one begin ... end</code></pre><p>This can be used inside a <code>@tasks for ... end</code> block to mark a region of code to be executed by only one of the parallel tasks (all other tasks skip over this region).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using OhMyThreads: @tasks

@tasks for i in 1:10
    @set ntasks = 10

    println(i, &quot;: before&quot;)
    @only_one begin
        println(i, &quot;: only printed by a single task&quot;)
        sleep(1)
    end
    println(i, &quot;: after&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/macros.jl#L165-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@one_by_one" href="#OhMyThreads.@one_by_one"><code>OhMyThreads.@one_by_one</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@one_by_one begin ... end</code></pre><p>This can be used inside a <code>@tasks for ... end</code> block to mark a region of code to be executed by one parallel task at a time (i.e. exclusive access). The order may be arbitrary and non-deterministic.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using OhMyThreads: @tasks

@tasks for i in 1:10
    @set ntasks = 10

    println(i, &quot;: before&quot;)
    @one_by_one begin
        println(i, &quot;: one task at a time&quot;)
        sleep(0.5)
    end
    println(i, &quot;: after&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/macros.jl#L192-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@allow_boxed_captures" href="#OhMyThreads.@allow_boxed_captures"><code>OhMyThreads.@allow_boxed_captures</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@allow_boxed_captures expr</code></pre><p>By default, OhMyThreads.jl will detect and error on multithreaded code which references local variables which are &#39;boxed&#39; – something that happens if the variable could be re-bound in multiple scopes. This process can cause very sublte bugs in multithreaded code by creating silent race conditions, e.g.</p><pre><code class="language-julia hljs">let
    function wrong()
        tmap(1:10) do i
            A = i # define A for the first time (lexically)
            sleep(rand()/10)
            A # user is trying to reference local A only
        end
    end
    @show wrong()
    A = 1 # boxed! this hoists &quot;A&quot; to the same variable as in `wrong` but presumably the user wanted a new one
end</code></pre><p>In this example, you might expect to get <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>, but you would actually observe incorrect results because <code>A</code> is &#39;boxed&#39;. The fix for this would be to write something like</p><pre><code class="language-julia hljs">let
    function right()
        tmap(1:10) do i
            local A = i
            sleep(rand()/10)
            A 
        end
    end
    @show right()
    A = 1
end</code></pre><p>However, if you are really sure you want to bypass OhMyThreads&#39;s error mechanism, you can use <code>@allow_boxed_captures</code> to wrap code you believe is okay, e.g.</p><pre><code class="language-julia-repl hljs">julia&gt; let A = 1 
           @allow_boxed_captures tmap(1:10) do i
               A = i
               sleep(rand()/10)
               A # race condition!
           end
       end
10-element Vector{Int64}:
 4
 2
 7
 2
 2
 8
 6
 8
 7
 2</code></pre><p>This is a dynamically scoped construct, so this effect will apply to <em>all</em> nested code inside of <code>expr</code>.</p><p>See also <code>@disallow_boxed_captures</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/macros.jl#L223-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@disallow_boxed_captures" href="#OhMyThreads.@disallow_boxed_captures"><code>OhMyThreads.@disallow_boxed_captures</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@disallow_boxed_captures expr</code></pre><p>Disable the effect of <code>@allow_boxed_captures</code> for any code in <code>expr</code>.</p><p>This is a dynamically scoped construct, so this effect will apply to <em>all</em> nested code inside of <code>expr</code>.</p><p>See also <code>@disallow_boxed_captures</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/macros.jl#L293-L301">source</a></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tmapreduce" href="#OhMyThreads.tmapreduce"><code>OhMyThreads.tmapreduce</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tmapreduce(f, op, A::AbstractArray...;
           [scheduler::Union{Scheduler, Symbol} = :dynamic],
           [outputtype::Type = Any],
           [init])</code></pre><p>A multithreaded function like <code>Base.mapreduce</code>. Perform a reduction over <code>A</code>, applying a single-argument function <code>f</code> to each element, and then combining them with the two-argument function <code>op</code>.</p><p>Note that <code>op</code> <strong>must</strong> be an <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> function, in the sense that <code>op(a, op(b, c)) ≈ op(op(a, b), c)</code>. If <code>op</code> is not (approximately) associative, you will get undefined results.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">using OhMyThreads: tmapreduce

tmapreduce(√, +, [1, 2, 3, 4, 5])</code></pre><p>is the parallelized version of <code>sum(√, [1, 2, 3, 4, 5])</code> in the form</p><pre><code class="nohighlight hljs">(√1 + √2) + (√3 + √4) + √5</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Union{Scheduler, Symbol}</code> (default <code>:dynamic</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information on the available schedulers.</li><li><code>outputtype::Type</code> (default <code>Any</code>): will work as the asserted output type of parallel calculations. We use <a href="https://github.com/JuliaFolds2/StableTasks.jl">StableTasks.jl</a> to make setting this option unnecessary, but if you experience problems with type stability, you may be able to recover it with this keyword argument.</li><li><code>init</code>: initial value of the reduction. Will be forwarded to <code>mapreduce</code> for the task-local sequential parts of the calculation.</li></ul><p>In addition, <code>tmapreduce</code> accepts <strong>all keyword arguments that are supported by the selected scheduler</strong>. They will simply be passed on to the corresponding <code>Scheduler</code> constructor. Example:</p><pre><code class="nohighlight hljs">tmapreduce(√, +, [1, 2, 3, 4, 5]; chunksize=2, scheduler=:static)</code></pre><p>However, to avoid ambiguity, this is currently <strong>only supported for <code>scheduler::Symbol</code></strong> (but not for <code>scheduler::Scheduler</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/functions.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.treduce" href="#OhMyThreads.treduce"><code>OhMyThreads.treduce</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">treduce(op, A::AbstractArray...;
        [scheduler::Union{Scheduler, Symbol} = :dynamic],
        [outputtype::Type = Any],
        [init])</code></pre><p>A multithreaded function like <code>Base.reduce</code>. Perform a reduction over <code>A</code> using the two-argument function <code>op</code>.</p><p>Note that <code>op</code> <strong>must</strong> be an <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> function, in the sense that <code>op(a, op(b, c)) ≈ op(op(a, b), c)</code>. If <code>op</code> is not (approximately) associative, you will get undefined results.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">using OhMyThreads: treduce

treduce(+, [1, 2, 3, 4, 5])</code></pre><p>is the parallelized version of <code>sum([1, 2, 3, 4, 5])</code> in the form</p><pre><code class="nohighlight hljs">(1 + 2) + (3 + 4) + 5</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Union{Scheduler, Symbol}</code> (default <code>:dynamic</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information on the available schedulers.</li><li><code>outputtype::Type</code> (default <code>Any</code>): will work as the asserted output type of parallel calculations. We use <a href="https://github.com/JuliaFolds2/StableTasks.jl">StableTasks.jl</a> to make setting this option unnecessary, but if you experience problems with type stability, you may be able to recover it with this keyword argument.</li><li><code>init</code>: initial value of the reduction. Will be forwarded to <code>mapreduce</code> for the task-local sequential parts of the calculation.</li></ul><p>In addition, <code>treduce</code> accepts <strong>all keyword arguments that are supported by the selected scheduler</strong>. They will simply be passed on to the corresponding <code>Scheduler</code> constructor. Example:</p><pre><code class="nohighlight hljs">treduce(+, [1, 2, 3, 4, 5]; chunksize=2, scheduler=:static)</code></pre><p>However, to avoid ambiguity, this is currently <strong>only supported for <code>scheduler::Symbol</code></strong> (but not for <code>scheduler::Scheduler</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/functions.jl#L92-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tmap" href="#OhMyThreads.tmap"><code>OhMyThreads.tmap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tmap(f, [OutputElementType], A::AbstractArray...;
     [scheduler::Union{Scheduler, Symbol} = :dynamic])</code></pre><p>A multithreaded function like <code>Base.map</code>. Create a new container <code>similar</code> to <code>A</code> and fills it in parallel such that the <code>i</code>th element is equal to <code>f(A[i])</code>.</p><p>The optional argument <code>OutputElementType</code> will select a specific element type for the returned container, and will generally incur fewer allocations than the version where <code>OutputElementType</code> is not specified.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">using OhMyThreads: tmap

tmap(sin, 1:10)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Union{Scheduler, Symbol}</code> (default <code>:dynamic</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information on the available schedulers.</li></ul><p>In addition, <code>tmap</code> accepts <strong>all keyword arguments that are supported by the selected scheduler</strong>. They will simply be passed on to the corresponding <code>Scheduler</code> constructor. Example:</p><pre><code class="nohighlight hljs">tmap(sin, 1:10; chunksize=2, scheduler=:static)</code></pre><p>However, to avoid ambiguity, this is currently <strong>only supported for <code>scheduler::Symbol</code></strong> (but not for <code>scheduler::Scheduler</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/functions.jl#L175-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tmap!" href="#OhMyThreads.tmap!"><code>OhMyThreads.tmap!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tmap!(f, out, A::AbstractArray...;
      [scheduler::Union{Scheduler, Symbol} = :dynamic])</code></pre><p>A multithreaded function like <code>Base.map!</code>. In parallel on multiple tasks, this function assigns each element of <code>out[i] = f(A[i])</code> for each index <code>i</code> of <code>A</code> and <code>out</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Union{Scheduler, Symbol}</code> (default <code>:dynamic</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information on the available schedulers.</li></ul><p>In addition, <code>tmap!</code> accepts <strong>all keyword arguments that are supported by the selected scheduler</strong>. They will simply be passed on to the corresponding <code>Scheduler</code> constructor. However, to avoid ambiguity, this is currently <strong>only supported for <code>scheduler::Symbol</code></strong> (but not for <code>scheduler::Scheduler</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/functions.jl#L208-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tforeach" href="#OhMyThreads.tforeach"><code>OhMyThreads.tforeach</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tforeach(f, A::AbstractArray...;
         [scheduler::Union{Scheduler, Symbol} = :dynamic]) :: Nothing</code></pre><p>A multithreaded function like <code>Base.foreach</code>. Apply <code>f</code> to each element of <code>A</code> on multiple parallel tasks, and return <code>nothing</code>. I.e. it is the parallel equivalent of</p><pre><code class="nohighlight hljs">for x in A
    f(x)
end</code></pre><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">using OhMyThreads: tforeach

tforeach(1:10) do i
    println(i^2)
end</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Union{Scheduler, Symbol}</code> (default <code>:dynamic</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information on the available schedulers.</li></ul><p>In addition, <code>tforeach</code> accepts <strong>all keyword arguments that are supported by the selected scheduler</strong>. They will simply be passed on to the corresponding <code>Scheduler</code> constructor. Example:</p><pre><code class="nohighlight hljs">tforeach(1:10; chunksize=2, scheduler=:static) do i
    println(i^2)
end</code></pre><p>However, to avoid ambiguity, this is currently <strong>only supported for <code>scheduler::Symbol</code></strong> (but not for <code>scheduler::Scheduler</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/functions.jl#L136-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tcollect" href="#OhMyThreads.tcollect"><code>OhMyThreads.tcollect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tcollect([OutputElementType], gen::Union{AbstractArray, Generator{&lt;:AbstractArray}};
         [scheduler::Union{Scheduler, Symbol} = :dynamic])</code></pre><p>A multithreaded function like <code>Base.collect</code>. Essentially just calls <code>tmap</code> on the generator function and inputs.</p><p>The optional argument <code>OutputElementType</code> will select a specific element type for the returned container, and will generally incur fewer allocations than the version where <code>OutputElementType</code> is not specified.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">using OhMyThreads: tcollect

tcollect(sin(i) for i in 1:10)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Union{Scheduler, Symbol}</code> (default <code>:dynamic</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information on the available schedulers.</li></ul><p>In addition, <code>tcollect</code> accepts <strong>all keyword arguments that are supported by the selected scheduler</strong>. They will simply be passed on to the corresponding <code>Scheduler</code> constructor. Example:</p><pre><code class="nohighlight hljs">tcollect(sin(i) for i in 1:10; chunksize=2, scheduler=:static)</code></pre><p>However, to avoid ambiguity, this is currently <strong>only supported for <code>scheduler::Symbol</code></strong> (but not for <code>scheduler::Scheduler</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/functions.jl#L226-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.treducemap" href="#OhMyThreads.treducemap"><code>OhMyThreads.treducemap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">treducemap(op, f, A::AbstractArray...;
           [scheduler::Union{Scheduler, Symbol} = :dynamic],
           [outputtype::Type = Any],
           [init])</code></pre><p>Like <code>tmapreduce</code> except the order of the <code>f</code> and <code>op</code> arguments are switched. This is sometimes convenient with <code>do</code>-block notation. Perform a reduction over <code>A</code>, applying a single-argument function <code>f</code> to each element, and then combining them with the two-argument function <code>op</code>.</p><p>Note that <code>op</code> <strong>must</strong> be an <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> function, in the sense that <code>op(a, op(b, c)) ≈ op(op(a, b), c)</code>. If <code>op</code> is not (approximately) associative, you will get undefined results.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">using OhMyThreads: treducemap

treducemap(+, √, [1, 2, 3, 4, 5])</code></pre><p>is the parallelized version of <code>sum(√, [1, 2, 3, 4, 5])</code> in the form</p><pre><code class="nohighlight hljs">(√1 + √2) + (√3 + √4) + √5</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Union{Scheduler, Symbol}</code> (default <code>:dynamic</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information on the available schedulers.</li><li><code>outputtype::Type</code> (default <code>Any</code>): will work as the asserted output type of parallel calculations. We use <a href="https://github.com/JuliaFolds2/StableTasks.jl">StableTasks.jl</a> to make setting this option unnecessary, but if you experience problems with type stability, you may be able to recover it with this keyword argument.</li><li><code>init</code>: initial value of the reduction. Will be forwarded to <code>mapreduce</code> for the task-local sequential parts of the calculation.</li></ul><p>In addition, <code>treducemap</code> accepts <strong>all keyword arguments that are supported by the selected scheduler</strong>. They will simply be passed on to the corresponding <code>Scheduler</code> constructor. Example:</p><pre><code class="nohighlight hljs">treducemap(+, √, [1, 2, 3, 4, 5]; chunksize=2, scheduler=:static)</code></pre><p>However, to avoid ambiguity, this is currently <strong>only supported for <code>scheduler::Symbol</code></strong> (but not for <code>scheduler::Scheduler</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/functions.jl#L46-L89">source</a></section></article><h3 id="Schedulers"><a class="docs-heading-anchor" href="#Schedulers">Schedulers</a><a id="Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Schedulers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.Scheduler" href="#OhMyThreads.Schedulers.Scheduler"><code>OhMyThreads.Schedulers.Scheduler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Supertype for all available schedulers:</p><ul><li><a href="#OhMyThreads.Schedulers.DynamicScheduler"><code>DynamicScheduler</code></a>: default dynamic scheduler</li><li><a href="#OhMyThreads.Schedulers.StaticScheduler"><code>StaticScheduler</code></a>: low-overhead static scheduler</li><li><a href="#OhMyThreads.Schedulers.GreedyScheduler"><code>GreedyScheduler</code></a>: greedy load-balancing scheduler</li><li><a href="#OhMyThreads.Schedulers.SerialScheduler"><code>SerialScheduler</code></a>: serial (non-parallel) execution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/schedulers.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.DynamicScheduler" href="#OhMyThreads.Schedulers.DynamicScheduler"><code>OhMyThreads.Schedulers.DynamicScheduler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DynamicScheduler (aka :dynamic)</code></pre><p>The default dynamic scheduler. Divides the given collection into chunks and then spawns a task per chunk to perform the requested operation in parallel. The tasks are assigned to threads by Julia&#39;s dynamic scheduler and are non-sticky, that is, they can migrate between threads.</p><p>Generally preferred since it is flexible, can provide load balancing, and is composable with other multithreaded code.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>nchunks::Integer</code> or <code>ntasks::Integer</code> (default <code>nthreads(threadpool)</code>):<ul><li>Determines the number of chunks (and thus also the number of parallel tasks).</li><li>Increasing <code>nchunks</code> can help with <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">load balancing</a>, but at the expense of creating more overhead. For <code>nchunks &lt;= nthreads()</code> there are not enough chunks for any load balancing.</li><li>Setting <code>nchunks &lt; nthreads()</code> is an effective way to use only a subset of the available threads.</li></ul></li><li><code>chunksize::Integer</code> (default not set)<ul><li>Specifies the desired chunk size (instead of the number of chunks).</li><li>The options <code>chunksize</code> and <code>nchunks</code>/<code>ntasks</code> are <strong>mutually exclusive</strong> (only one may be a positive integer).</li></ul></li><li><code>split::Union{Symbol, OhMyThreads.Split}</code> (default <code>OhMyThreads.Consecutive()</code>):<ul><li>Determines how the collection is divided into chunks (if chunking=true). By default, each chunk consists of contiguous elements and order is maintained.</li><li>See <a href="https://github.com/JuliaFolds2/ChunkSplitters.jl">ChunkSplitters.jl</a> for more details and available options. We also allow users to pass <code>:consecutive</code> in place of <code>Consecutive()</code>, and <code>:roundrobin</code> in place of <code>RoundRobin()</code></li><li>Beware that for <code>split=OhMyThreads.RoundRobin()</code> the order of elements isn&#39;t maintained and a reducer function must not only be associative but also <strong>commutative</strong>!</li></ul></li><li><code>chunking::Bool</code> (default <code>true</code>):<ul><li>Controls whether input elements are grouped into chunks (<code>true</code>) or not (<code>false</code>).</li><li>For <code>chunking=false</code>, the arguments <code>nchunks</code>/<code>ntasks</code>, <code>chunksize</code>, and <code>split</code> are ignored and input elements are regarded as &quot;chunks&quot; as is. Hence, there will be one parallel task spawned per input element. Note that, depending on the input, this <strong>might spawn many(!) tasks</strong> and can be costly!</li></ul></li><li><code>threadpool::Symbol</code> (default <code>:default</code>):<ul><li>Possible options are <code>:default</code> and <code>:interactive</code>.</li><li>The high-priority pool <code>:interactive</code> should be used very carefully since tasks on this threadpool should not be allowed to run for a long time without <code>yield</code>ing as it can interfere with <a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">heartbeat</a> processes.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/schedulers.jl#L163-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.StaticScheduler" href="#OhMyThreads.Schedulers.StaticScheduler"><code>OhMyThreads.Schedulers.StaticScheduler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticScheduler (aka :static)</code></pre><p>A static low-overhead scheduler. Divides the given collection into chunks and then spawns a task per chunk to perform the requested operation in parallel. The tasks are statically assigned to threads up front and are made <em>sticky</em>, that is, they are guaranteed to stay on the assigned threads (<strong>no task migration</strong>).</p><p>Can sometimes be more performant than <code>DynamicScheduler</code> when the workload is (close to) uniform and, because of the lower overhead, for small workloads. Isn&#39;t well composable with other multithreaded code though.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>nchunks::Integer</code> or <code>ntasks::Integer</code> (default <code>nthreads()</code>):<ul><li>Determines the number of chunks (and thus also the number of parallel tasks).</li><li>Setting <code>nchunks &lt; nthreads()</code> is an effective way to use only a subset of the available threads.</li><li>For <code>nchunks &gt; nthreads()</code> the chunks will be distributed to the available threads in a round-robin fashion.</li></ul></li><li><code>chunksize::Integer</code> (default not set)<ul><li>Specifies the desired chunk size (instead of the number of chunks).</li><li>The options <code>chunksize</code> and <code>nchunks</code>/<code>ntasks</code> are <strong>mutually exclusive</strong> (only one may be non-zero).</li></ul></li><li><code>chunking::Bool</code> (default <code>true</code>):<ul><li>Controls whether input elements are grouped into chunks (<code>true</code>) or not (<code>false</code>).</li><li>For <code>chunking=false</code>, the arguments <code>nchunks</code>/<code>ntasks</code>, <code>chunksize</code>, and <code>split</code> are ignored and input elements are regarded as &quot;chunks&quot; as is. Hence, there will be one parallel task spawned per input element. Note that, depending on the input, this <strong>might spawn many(!) tasks</strong> and can be costly!</li></ul></li><li><code>split::Union{Symbol, OhMyThreads.Split}</code> (default <code>OhMyThreads.Consecutive()</code>):<ul><li>Determines how the collection is divided into chunks. By default, each chunk consists of contiguous elements and order is maintained.</li><li>See <a href="https://github.com/JuliaFolds2/ChunkSplitters.jl">ChunkSplitters.jl</a> for more details and available options. We also allow users to pass <code>:consecutive</code> in place of <code>Consecutive()</code>, and <code>:roundrobin</code> in place of <code>RoundRobin()</code></li><li>Beware that for <code>split=OhMyThreads.RoundRobin()</code> the order of elements isn&#39;t maintained and a reducer function must not only be associative but also <strong>commutative</strong>!</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/schedulers.jl#L232-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.GreedyScheduler" href="#OhMyThreads.Schedulers.GreedyScheduler"><code>OhMyThreads.Schedulers.GreedyScheduler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GreedyScheduler (aka :greedy)</code></pre><p>A greedy dynamic scheduler. The elements are put into a shared workqueue and dynamic, non-sticky, tasks are spawned to process the elements of the queue with each task taking a new element from the queue as soon as the previous one is done.</p><p>Note that elements are processed in a non-deterministic order, and thus a potential reducing function <strong>must</strong> be <a href="https://en.wikipedia.org/wiki/Commutative_property">commutative</a> in addition to being associative, or you could get incorrect results!</p><p>Can be good choice for load-balancing slower, uneven computations, but does carry some additional overhead.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>ntasks::Int</code> (default <code>nthreads()</code>):<ul><li>Determines the number of parallel tasks to be spawned.</li><li>Setting <code>ntasks &lt; nthreads()</code> is an effective way to use only a subset of the available threads.</li></ul></li><li><code>chunking::Bool</code> (default <code>false</code>):<ul><li>Controls whether input elements are grouped into chunks (<code>true</code>) or not (<code>false</code>) before put into the shared workqueue. This can improve the performance especially if there are many iterations each of which are computationally cheap.</li><li>If <code>nchunks</code> or <code>chunksize</code> are explicitly specified, <code>chunking</code> will be automatically set to <code>true</code>.</li></ul></li><li><code>nchunks::Integer</code> (default <code>10 * nthreads()</code>):<ul><li>Determines the number of chunks (that will eventually be put into the shared workqueue).</li><li>Increasing <code>nchunks</code> can help with <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">load balancing</a>. For <code>nchunks &lt;= nthreads()</code> there are not enough chunks for any load balancing.</li></ul></li><li><code>chunksize::Integer</code> (default not set)<ul><li>Specifies the desired chunk size (instead of the number of chunks).</li><li>The options <code>chunksize</code> and <code>nchunks</code> are <strong>mutually exclusive</strong> (only one may be a positive integer).</li></ul></li><li><code>split::Union{Symbol, OhMyThreads.Split}</code> (default <code>OhMyThreads.RoundRobin()</code>):<ul><li>Determines how the collection is divided into chunks (if chunking=true).</li><li>See <a href="https://github.com/JuliaFolds2/ChunkSplitters.jl">ChunkSplitters.jl</a> for more details and available options. We also allow users to pass <code>:consecutive</code> in place of <code>Consecutive()</code>, and <code>:roundrobin</code> in place of <code>RoundRobin()</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/schedulers.jl#L290-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.SerialScheduler" href="#OhMyThreads.Schedulers.SerialScheduler"><code>OhMyThreads.Schedulers.SerialScheduler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SerialScheduler (aka :serial)</code></pre><p>A scheduler for turning off any multithreading and running the code in serial. It aims to make parallel functions like, e.g., <code>tmapreduce(sin, +, 1:100)</code> behave like their serial counterparts, e.g., <code>mapreduce(sin, +, 1:100)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/schedulers.jl#L356-L362">source</a></section></article><h2 id="Re-exported"><a class="docs-heading-anchor" href="#Re-exported">Re-exported</a><a id="Re-exported-1"></a><a class="docs-heading-anchor-permalink" href="#Re-exported" title="Permalink"></a></h2><table><tr><th style="text-align: right"></th><th style="text-align: right"></th></tr><tr><td style="text-align: right"><code>OhMyThreads.chunks</code></td><td style="text-align: right">see <a href="https://juliafolds2.github.io/ChunkSplitters.jl/stable/references/#ChunkSplitters.chunks"><code>ChunkSplitters.chunks</code></a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.index_chunks</code></td><td style="text-align: right">see <a href="https://juliafolds2.github.io/ChunkSplitters.jl/stable/references/#ChunkSplitters.index_chunks"><code>ChunkSplitters.index_chunks</code></a></td></tr></table><h2 id="Public-but-not-exported"><a class="docs-heading-anchor" href="#Public-but-not-exported">Public but not exported</a><a id="Public-but-not-exported-1"></a><a class="docs-heading-anchor-permalink" href="#Public-but-not-exported" title="Permalink"></a></h2><table><tr><th style="text-align: right"></th><th style="text-align: right"></th></tr><tr><td style="text-align: right"><code>OhMyThreads.@spawn</code></td><td style="text-align: right">see <a href="https://github.com/JuliaFolds2/StableTasks.jl"><code>StableTasks.@spawn</code></a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.@spawnat</code></td><td style="text-align: right">see <a href="https://github.com/JuliaFolds2/StableTasks.jl"><code>StableTasks.@spawnat</code></a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.@fetch</code></td><td style="text-align: right">see <a href="https://github.com/JuliaFolds2/StableTasks.jl"><code>StableTasks.@fetch</code></a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.@fetchfrom</code></td><td style="text-align: right">see <a href="https://github.com/JuliaFolds2/StableTasks.jl"><code>StableTasks.@fetchfrom</code></a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.TaskLocalValue</code></td><td style="text-align: right">see <a href="https://github.com/vchuravy/TaskLocalValues.jl">TaskLocalValues.TaskLocalValue</a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.Split</code></td><td style="text-align: right">see <a href="https://juliafolds2.github.io/ChunkSplitters.jl/stable/references/#ChunkSplitters.Split"><code>ChunkSplitters.Split</code></a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.Consecutive</code></td><td style="text-align: right">see <a href="https://juliafolds2.github.io/ChunkSplitters.jl/stable/references/#ChunkSplitters.Consecutive"><code>ChunkSplitters.Consecutive</code></a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.RoundRobin</code></td><td style="text-align: right">see <a href="https://juliafolds2.github.io/ChunkSplitters.jl/stable/references/#ChunkSplitters.RoundRobin"><code>ChunkSplitters.RoundRobin</code></a></td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.WithTaskLocals" href="#OhMyThreads.WithTaskLocals"><code>OhMyThreads.WithTaskLocals</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct WithTaskLocals{F, TLVs &lt;: Tuple{Vararg{TaskLocalValue}}} &lt;: Function</code></pre><p>This callable function-like object is meant to represent a function which closes over some <a href="https://github.com/vchuravy/TaskLocalValues.jl"><code>TaskLocalValues</code></a>. This is, if you do</p><pre><code class="nohighlight hljs">TLV{T} = TaskLocalValue{T}
f = WithTaskLocals((TLV{Int}(() -&gt; 1), TLV{Int}(() -&gt; 2))) do (x, y)
    z -&gt; (x + y)/z
end</code></pre><p>then that is equivalent to</p><pre><code class="nohighlight hljs">g = let x = TLV{Int}(() -&gt; 1), y = TLV{Int}(() -&gt; 2)
    z -&gt; let x = x[], y=y[]
        (x + y)/z
    end
end</code></pre><p>however, the main difference is that you can call <a href="#OhMyThreads.promise_task_local"><code>promise_task_local</code></a> on a <code>WithTaskLocals</code> closure in order to turn it into something equivalent to</p><pre><code class="nohighlight hljs">let x=x[], y=y[]
    z -&gt; (x + y)/z
end</code></pre><p>which doesn&#39;t have the overhead of accessing the <code>task_local_storage</code> each time the closure is called. This of course will lose the safety advantages of <code>TaskLocalValue</code>, so you should never do <code>f_local = promise_task_local(f)</code> and then pass <code>f_local</code> to some unknown function, because if that unknown function calls <code>f_local</code> on a new task, you&#39;ll hit a race condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/types.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.promise_task_local" href="#OhMyThreads.promise_task_local"><code>OhMyThreads.promise_task_local</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">promise_task_local(f) = f
promise_task_local(f::WithTaskLocals) = f.inner_func(map(x -&gt; x[], f.tasklocals))</code></pre><p>Take a <code>WithTaskLocals</code> closure, grab the <code>TaskLocalValue</code>s, and passs them to the closure. That is, it turns a <code>WithTaskLocals</code> closure from the equivalent of</p><pre><code class="nohighlight hljs">TLV{T} = TaskLocalValue{T}
let x = TLV{Int}(() -&gt; 1), y = TLV{Int}(() -&gt; 2)
    z -&gt; let x = x[], y=y[]
        (x + y)/z
    end
end</code></pre><p>into the equivalent of</p><pre><code class="nohighlight hljs">let x = TLV{Int}(() -&gt; 1), y = TLV{Int}(() -&gt; 2)
    let x = x[], y = y[]
        z -&gt; (x + y)/z
    end
end</code></pre><p>which doesn&#39;t have the overhead of accessing the <code>task_local_storage</code> each time the closure is called. This of course will lose the safety advantages of <code>TaskLocalValue</code>, so you should never do <code>f_local = promise_task_local(f)</code> and then pass <code>f_local</code> to some unknown function, because if that unknown function calls <code>f_local</code> on a new task, you&#39;ll hit a race condition.  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/types.jl#L38-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.ChannelLike" href="#OhMyThreads.ChannelLike"><code>OhMyThreads.ChannelLike</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChannelLike(itr)</code></pre><p>This struct wraps an indexable object such that it can be iterated by concurrent tasks in a safe manner similar to a <code>Channel</code>.</p><p><code>ChannelLike(itr)</code> is conceptually similar to:</p><pre><code class="language-julia hljs">Channel{eltype(itr)}(length(itr)) do ch
    foreach(i -&gt; put!(ch, i), itr)
end</code></pre><p>i.e. creating a channel, <code>put!</code>ing all elements of <code>itr</code> into it and closing it. The advantage is that <code>ChannelLike</code> doesn&#39;t copy the data.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ch = OhMyThreads.ChannelLike(1:5)

@sync for taskid in 1:2
    Threads.@spawn begin
        for i in ch
            println(&quot;Task #$taskid processing item $i&quot;)
            sleep(1 / i)
        end
    end
end

# output

Task #1 processing item 1
Task #2 processing item 2
Task #2 processing item 3
Task #2 processing item 4
Task #1 processing item 5</code></pre><p>Note that <code>ChannelLike</code> is stateful (just like a <code>Channel</code>), so you can&#39;t iterate over it twice.</p><p>The wrapped iterator must support <code>firstindex(itr)::Int</code>, <code>lastindex(itr)::Int</code> and <code>getindex(itr, ::Int)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/d42d93ccea850acc931c84d135d8dc4bf9b5bb74/src/types.jl#L75-L117">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../literate/falsesharing/falsesharing/">« False Sharing</a><a class="docs-footer-nextpage" href="../experimental/">Experimental »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Monday 17 March 2025 15:37">Monday 17 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
