<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Thread-Safe Storage ¬∑ OhMyThreads.jl</title><meta name="title" content="Thread-Safe Storage ¬∑ OhMyThreads.jl"/><meta property="og:title" content="Thread-Safe Storage ¬∑ OhMyThreads.jl"/><meta property="twitter:title" content="Thread-Safe Storage ¬∑ OhMyThreads.jl"/><meta name="description" content="Documentation for OhMyThreads.jl."/><meta property="og:description" content="Documentation for OhMyThreads.jl."/><meta property="twitter:description" content="Documentation for OhMyThreads.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">OhMyThreads.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">OhMyThreads</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting Started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Thread-Safe Storage</a><ul class="internal"><li><a class="tocitem" href="#Sequential"><span>Sequential</span></a></li><li><a class="tocitem" href="#The-wrong-way"><span>The wrong way</span></a></li><li><a class="tocitem" href="#The-naive-(and-inefficient)-way"><span>The naive (and inefficient) way</span></a></li><li><a class="tocitem" href="#The-manual-(and-cumbersome)-way"><span>The manual (and cumbersome) way</span></a></li><li><a class="tocitem" href="#TLS"><span>The good way: Task-local storage</span></a></li><li><a class="tocitem" href="#Benchmark"><span>Benchmark</span></a></li><li><a class="tocitem" href="#Per-thread-allocation:-the-bad-way"><span>Per-thread allocation: the bad way</span></a></li><li><a class="tocitem" href="#Per-thread-allocation:-the-kind-of-ok-way"><span>Per-thread allocation: the kind of ok way</span></a></li><li><a class="tocitem" href="#Per-thread-allocation:-the-good-way-(Channel)"><span>Per-thread allocation: the good way (<code>Channel</code>)</span></a></li><li><a class="tocitem" href="#Per-thread-allocation:-benchmark"><span>Per-thread allocation: benchmark</span></a></li><li><a class="tocitem" href="#Per-thread-allocation:-another-good-way-(Channel)"><span>Per-thread allocation: another good way (<code>Channel</code>)</span></a></li></ul></li><li><a class="tocitem" href="../../../translation/">Translation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../mc/mc/">Parallel Monte Carlo</a></li><li><a class="tocitem" href="../../juliaset/juliaset/">Julia Set</a></li><li><a class="tocitem" href="../../integration/integration/">Trapezoidal Integration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../refs/api/">Public API</a></li><li><a class="tocitem" href="../../../refs/internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href>Thread-Safe Storage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Thread-Safe Storage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaFolds2/OhMyThreads.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/master/docs/src/literate/tls/tls.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TSS"><a class="docs-heading-anchor" href="#TSS">Thread-Safe Storage</a><a id="TSS-1"></a><a class="docs-heading-anchor-permalink" href="#TSS" title="Permalink"></a></h1><p>For some programs, it can be useful or even necessary to allocate and (re-)use memory in your parallel code (e.g. your computation might require temporary buffers). The following section demonstrates common issues that can arise in such a scenario and, by means of a simple example, explains techniques to handle such cases safely. Specifically, we&#39;ll dicuss (1) how task-local storage (TLS) can be used efficiently and (2) how channels can be used to organize per-task buffer allocation in a thread-safe manner.</p><h2 id="Sequential"><a class="docs-heading-anchor" href="#Sequential">Sequential</a><a id="Sequential-1"></a><a class="docs-heading-anchor-permalink" href="#Sequential" title="Permalink"></a></h2><p>Let&#39;s say that we are given two arrays of matrices, <code>As</code> and <code>Bs</code>, and let&#39;s further assume that our goal is to compute the total sum of all pairwise matrix products. We can readily implement a (sequential) function that performs the necessary computations.</p><pre><code class="language-julia hljs">using LinearAlgebra: mul!, BLAS
BLAS.set_num_threads(1) #  for simplicity, we turn off OpenBLAS multithreading

function matmulsums(As, Bs)
    N = size(first(As), 1)
    C = Matrix{Float64}(undef, N, N)
    map(As, Bs) do A, B
        mul!(C, A, B)
        sum(C)
    end
end</code></pre><pre><code class="nohighlight hljs">matmulsums (generic function with 1 method)</code></pre><p>Here, we use <code>map</code> to perform the desired operation for each pair of matrices, <code>A</code> and <code>B</code>. However, the crucial point for our discussion is that we want to use the in-place matrix multiplication <code>LinearAlgebra.mul!</code> in conjunction with a pre-allocated temporary buffer, the output matrix <code>C</code>. This is to avoid the temporary allocation per &quot;iteration&quot; (i.e. per matrix pair) that we would get with <code>C = A*B</code>.</p><p>For later comparison, we generate some random input data and store the result.</p><pre><code class="language-julia hljs">As = [rand(2056, 32) for _ in 1:192]
Bs = [rand(32, 2056) for _ in 1:192]

res = matmulsums(As, Bs);</code></pre><h2 id="The-wrong-way"><a class="docs-heading-anchor" href="#The-wrong-way">The wrong way</a><a id="The-wrong-way-1"></a><a class="docs-heading-anchor-permalink" href="#The-wrong-way" title="Permalink"></a></h2><p>The key idea for creating a parallel version of <code>matmulsums</code> is to replace the <code>map</code> by OhMyThreads&#39; parallel <a href="../../../refs/api/#OhMyThreads.tmap"><code>tmap</code></a> function. However, because we re-use <code>C</code>, this isn&#39;t entirely trivial. Someone new to parallel computing might be tempted to parallelize <code>matmulsums</code> like this:</p><pre><code class="language-julia hljs">using OhMyThreads: tmap

function matmulsums_race(As, Bs)
    N = size(first(As), 1)
    C = Matrix{Float64}(undef, N, N)
    tmap(As, Bs) do A, B
        mul!(C, A, B)
        sum(C)
    end
end</code></pre><pre><code class="nohighlight hljs">matmulsums_race (generic function with 1 method)</code></pre><p>Unfortunately, this doesn&#39;t produce the correct result.</p><pre><code class="language-julia hljs">res_race = matmulsums_race(As, Bs)
res ‚âà res_race</code></pre><pre><code class="nohighlight hljs">false</code></pre><p>In fact, it doesn&#39;t even always produce the same result (check for yourself)! The reason is that there is a race condition: different parallel tasks are trying to use the shared variable <code>C</code> simultaneously leading to non-deterministic behavior. Let&#39;s see how we can fix this.</p><h2 id="The-naive-(and-inefficient)-way"><a class="docs-heading-anchor" href="#The-naive-(and-inefficient)-way">The naive (and inefficient) way</a><a id="The-naive-(and-inefficient)-way-1"></a><a class="docs-heading-anchor-permalink" href="#The-naive-(and-inefficient)-way" title="Permalink"></a></h2><p>A simple solution for the race condition issue above is to move the allocation of <code>C</code> into the body of the parallel <code>tmap</code>:</p><pre><code class="language-julia hljs">function matmulsums_naive(As, Bs)
    N = size(first(As), 1)
    tmap(As, Bs) do A, B
        C = Matrix{Float64}(undef, N, N)
        mul!(C, A, B)
        sum(C)
    end
end</code></pre><pre><code class="nohighlight hljs">matmulsums_naive (generic function with 1 method)</code></pre><p>In this case, a separate <code>C</code> will be allocated for each iteration such that parallel tasks don&#39;t modify shared state anymore. Hence, we&#39;ll get the desired result.</p><pre><code class="language-julia hljs">res_naive = matmulsums_naive(As, Bs)
res ‚âà res_naive</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>However, this variant is obviously inefficient because it is no better than just writing <code>C = A*B</code> and thus leads to one allocation per matrix pair. We need a different way of allocating and re-using <code>C</code> for an efficient parallel version.</p><h2 id="The-manual-(and-cumbersome)-way"><a class="docs-heading-anchor" href="#The-manual-(and-cumbersome)-way">The manual (and cumbersome) way</a><a id="The-manual-(and-cumbersome)-way-1"></a><a class="docs-heading-anchor-permalink" href="#The-manual-(and-cumbersome)-way" title="Permalink"></a></h2><p>We&#39;ve seen that we can&#39;t allocate <code>C</code> once up-front (‚Üí race condition) and also shouldn&#39;t allocate it within the <code>tmap</code> (‚Üí one allocation per iteration). Instead, we can assign a separate &quot;C&quot; on each parallel task once and then use this task-local &quot;C&quot; for all iterations (i.e. matrix pairs) for which this task is responsible. Before we learn how to do this more conveniently, let&#39;s implement this idea of a task-local temporary buffer (for each parallel task) manually.</p><pre><code class="language-julia hljs">using OhMyThreads: chunks, @spawn
using Base.Threads: nthreads

function matmulsums_manual(As, Bs)
    N = size(first(As), 1)
    tasks = map(chunks(As; n = 2 * nthreads())) do idcs
        @spawn begin
            local C = Matrix{Float64}(undef, N, N)
            map(idcs) do i
                A = As[i]
                B = Bs[i]

                mul!(C, A, B)
                sum(C)
            end
        end
    end
    mapreduce(fetch, vcat, tasks)
end

res_manual = matmulsums_manual(As, Bs)
res ‚âà res_manual</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>We note that this is rather cumbersome and you might not want to write it (repeatedly). But let&#39;s take a closer look and see what&#39;s happening here. First, we divide the number of matrix pairs into <code>2 * nthreads()</code> chunks. Then, for each of those chunks, we spawn a parallel task that (1) allocates a task-local <code>C</code> matrix (and a <code>results</code> vector) and (2) performs the actual computations using these pre-allocated buffers. Finally, we <code>fetch</code> the results of the tasks and combine them. This variant works just fine and the good news is that we can get the same behavior with less manual work.</p><h2 id="TLS"><a class="docs-heading-anchor" href="#TLS">The good way: Task-local storage</a><a id="TLS-1"></a><a class="docs-heading-anchor-permalink" href="#TLS" title="Permalink"></a></h2><p>The desire for task-local storage is quite natural with task-based multithreading. For this reason, Julia supports this out of the box with <a href="https://docs.julialang.org/en/v1/base/parallel/#Base.task_local_storage-Tuple{Any}"><code>Base.task_local_storage</code></a>. But instead of using this directly (which you could), we will use a convenience wrapper around it called <a href="https://github.com/vchuravy/TaskLocalValues.jl"><code>TaskLocalValue</code></a>. This allows us to express the idea from above in few lines of code:</p><pre><code class="language-julia hljs">using OhMyThreads: TaskLocalValue

function matmulsums_tlv(As, Bs; kwargs...)
    N = size(first(As), 1)
    tlv = TaskLocalValue{Matrix{Float64}}(() -&gt; Matrix{Float64}(undef, N, N))
    tmap(As, Bs; kwargs...) do A, B
        C = tlv[]
        mul!(C, A, B)
        sum(C)
    end
end

res_tlv = matmulsums_tlv(As, Bs)
res ‚âà res_tlv</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>Here, <code>TaskLocalValue{Matrix{Float64}}(() -&gt; Matrix{Float64}(undef, N, N))</code> creates a task-local value - essentially a reference to a value in the task-local storage - that behaves like this: The first time the task-local value is accessed from a task (<code>tls[]</code>) it is initialized according to the provided anonymous function. Afterwards, every following query (from the same task!) will simply lookup and return the task-local value. This solves our issues above and leads to <span>$O(\textrm{parallel tasks})$</span> (instead of <span>$O(\textrm{iterations})$</span>) allocations.</p><h2 id="Benchmark"><a class="docs-heading-anchor" href="#Benchmark">Benchmark</a><a id="Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark" title="Permalink"></a></h2><p>The whole point of parallelization is increasing performance, so let&#39;s benchmark and compare the performance of the variants that we&#39;ve discussed so far.</p><pre><code class="language-julia hljs">using BenchmarkTools

@show nthreads()

@btime matmulsums($As, $Bs);
@btime matmulsums_naive($As, $Bs);
@btime matmulsums_manual($As, $Bs);
@btime matmulsums_tlv($As, $Bs);</code></pre><pre><code class="nohighlight hljs">nthreads() = 10
  1.462 s (3 allocations: 32.25 MiB)
  952.502 ms (539 allocations: 6.05 GiB)
  744.719 ms (200 allocations: 645.04 MiB)
  743.187 ms (236 allocations: 645.04 MiB)
</code></pre><p>As we can see, <code>matmulsums_tlv</code> (the version using <code>TaskLocalValue</code>) isn&#39;t only convenient but also efficient: It allocates much less memory than <code>matmulsums_naive</code> and is about on par with the manual implementation.</p><h3 id="Tuning-the-scheduling"><a class="docs-heading-anchor" href="#Tuning-the-scheduling">Tuning the scheduling</a><a id="Tuning-the-scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-the-scheduling" title="Permalink"></a></h3><p>Since the workload is uniform, we don&#39;t need load balancing. We can thus try to improve the performance and reduce the number of allocations by choosing the number of chunks (i.e. tasks) to match the number of Julia threads. Concretely, this amounts to passing in <code>DynamicScheduler(; nchunks=nthreads())</code>. If we further want to opt-out of dynamic scheduling alltogether, we can choose the <code>StaticScheduler()</code>.</p><pre><code class="language-julia hljs">using OhMyThreads: DynamicScheduler, StaticScheduler

@btime matmulsums_tlv(
    $As, $Bs; scheduler = $(DynamicScheduler(; nchunks = nthreads())));
@btime matmulsums_tlv($As, $Bs; scheduler = $(StaticScheduler()));</code></pre><pre><code class="nohighlight hljs">  886.151 ms (124 allocations: 322.52 MiB)
  879.872 ms (122 allocations: 322.52 MiB)
</code></pre><h2 id="Per-thread-allocation:-the-bad-way"><a class="docs-heading-anchor" href="#Per-thread-allocation:-the-bad-way">Per-thread allocation: the bad way</a><a id="Per-thread-allocation:-the-bad-way-1"></a><a class="docs-heading-anchor-permalink" href="#Per-thread-allocation:-the-bad-way" title="Permalink"></a></h2><p>The task-local solution above has one potential caveat: If we spawn many parallel tasks (e.g. for load-balancing reasons) we need just as many task-local buffers. This can clearly be suboptimal because only <code>nthreads()</code> tasks can run simultaneously. Hence, one buffer per thread should actually suffice. Of course, this raises the question of how to organize a pool of &quot;per-thread&quot; buffers such that each running task always has exclusive (temporary) access to a buffer (we need to make sure to avoid races).</p><p>A naive approach to implementing this idea is to pre-allocate an array of buffers and then to use the <code>threadid()</code> to select a buffer for a running task.</p><pre><code class="language-julia hljs">using Base.Threads: threadid

function matmulsums_perthread_naive(As, Bs)
    N = size(first(As), 1)
    Cs = [Matrix{Float64}(undef, N, N) for _ in 1:nthreads()]
    tmap(As, Bs) do A, B
        C = Cs[threadid()]
        mul!(C, A, B)
        sum(C)
    end
end

res_pt_naive = matmulsums_perthread_naive(As, Bs)
res ‚âà res_pt_naive</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>Unfortunately, this approach is <a href="https://julialang.org/blog/2023/07/PSA-dont-use-threadid/"><strong>generally wrong</strong></a>. The first issue is that <code>threadid()</code> doesn&#39;t necessarily start at 1 (and thus might return a value <code>&gt; nthreads()</code>), in which case <code>Cs[threadid()]</code> would be an out-of-bounds access attempt. This might be surprising but is a simple consequence of the ordering of different kinds of Julia threads: If Julia is started with a non-zero number of interactive threads, e.g. <code>--threads 5,2</code>, the interactive threads come first (look at <code>Threads.threadpool.(1:Threads.maxthreadid())</code>).</p><p>But even if we account for this offset there is another, more fundamental problem, namely <strong>task-migration</strong>. By default, all spawned parallel tasks are &quot;non-sticky&quot; and can dynamically migrate between different Julia threads (loosely speaking, at any point in time). This means nothing other than that <strong><code>threadid()</code> is not necessarily constant for a task</strong>! For example, imagine that task A starts on thread 4, loads the buffer <code>Cs[4]</code>, but then gets paused, migrated, and continues executation on, say, thread 5. Afterwards, while task A is performing <code>mul!(Cs[4], ...)</code>, a different task B might start on (the now available) thread 4 and also read and use <code>Cs[4]</code>. This would lead to a race condition because both tasks are mutating the same buffer. (Note that, in practice, this - most likely üòâ - doesn&#39;t happen for the very simple example above, but you can&#39;t rely on it!)</p><h2 id="Per-thread-allocation:-the-kind-of-ok-way"><a class="docs-heading-anchor" href="#Per-thread-allocation:-the-kind-of-ok-way">Per-thread allocation: the kind of ok way</a><a id="Per-thread-allocation:-the-kind-of-ok-way-1"></a><a class="docs-heading-anchor-permalink" href="#Per-thread-allocation:-the-kind-of-ok-way" title="Permalink"></a></h2><p>A simple solution for the task-migration issue is to opt-out of dynamic scheduling with the <code>StaticScheduler()</code>. This scheduler statically assigns tasks to threads upfront without any dynamic rescheduling (the tasks are sticky and won&#39;t migrate).</p><pre><code class="language-julia hljs">function matmulsums_perthread_static(As, Bs)
    N = size(first(As), 1)
    Cs = [Matrix{Float64}(undef, N, N) for _ in 1:nthreads()]
    tmap(As, Bs; scheduler = StaticScheduler()) do A, B
        C = Cs[threadid()]
        mul!(C, A, B)
        sum(C)
    end
end

res_pt_static = matmulsums_perthread_static(As, Bs)
res ‚âà res_pt_static</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>However, this approach doesn&#39;t solve the offset issue and, even worse, makes the parallel code non-composable: If we call other multithreaded functions within the <code>tmap</code> or if our parallel <code>matmulsums_perthread_static</code> itself gets called from another parallel region we will likely oversubscribe the Julia threads and get subpar performance. Given these caveats, we should therefore generally take a different approach.</p><h2 id="Per-thread-allocation:-the-good-way-(Channel)"><a class="docs-heading-anchor" href="#Per-thread-allocation:-the-good-way-(Channel)">Per-thread allocation: the good way (<code>Channel</code>)</a><a id="Per-thread-allocation:-the-good-way-(Channel)-1"></a><a class="docs-heading-anchor-permalink" href="#Per-thread-allocation:-the-good-way-(Channel)" title="Permalink"></a></h2><p>Instead of storing the pre-allocated buffers in an array, we can put them into a <code>Channel</code> which internally ensures that parallel access is safe. In this scenario, we simply <code>take!</code> a buffer from the channel whenever we need it and <code>put!</code> it back after our computation is done.</p><pre><code class="language-julia hljs">function matmulsums_perthread_channel(As, Bs; nbuffers = nthreads(), kwargs...)
    N = size(first(As), 1)
    chnl = Channel{Matrix{Float64}}(nbuffers)
    foreach(1:nbuffers) do _
        put!(chnl, Matrix{Float64}(undef, N, N))
    end
    tmap(As, Bs; kwargs...) do A, B
        C = take!(chnl)
        mul!(C, A, B)
        result = sum(C)
        put!(chnl, C)
        result
    end
end

res_pt_channel = matmulsums_perthread_channel(As, Bs)
res ‚âà res_pt_channel</code></pre><pre><code class="nohighlight hljs">true</code></pre><h2 id="Per-thread-allocation:-benchmark"><a class="docs-heading-anchor" href="#Per-thread-allocation:-benchmark">Per-thread allocation: benchmark</a><a id="Per-thread-allocation:-benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Per-thread-allocation:-benchmark" title="Permalink"></a></h2><p>Let&#39;s benchmark the variants above and compare them to the task-local implementation. We want to look at both <code>nchunks = nthreads()</code> and <code>nchunks = 10 * nthreads()</code>, the latter of which would give us dynamic load balancing. (Note, though, that our exemplatory workload is uniform and thus won&#39;t benefit from load balancing.)</p><pre><code class="language-julia hljs">@btime matmulsums_tlv(
    $As, $Bs; scheduler = $(DynamicScheduler(; nchunks = nthreads())));
@btime matmulsums_perthread_static($As, $Bs);
@btime matmulsums_perthread_channel(
    $As, $Bs; scheduler = $(DynamicScheduler(; nchunks = nthreads())));

@btime matmulsums_tlv(
    $As, $Bs; scheduler = $(DynamicScheduler(; nchunks = 10 * nthreads())));
@btime matmulsums_perthread_channel(
    $As, $Bs; scheduler = $(DynamicScheduler(; nchunks = 10 * nthreads())));</code></pre><pre><code class="nohighlight hljs">  874.458 ms (124 allocations: 322.52 MiB)
  879.347 ms (105 allocations: 322.52 MiB)
  903.603 ms (112 allocations: 322.52 MiB)
  901.272 ms (1116 allocations: 3.15 GiB)
  795.640 ms (744 allocations: 322.58 MiB)
</code></pre><h2 id="Per-thread-allocation:-another-good-way-(Channel)"><a class="docs-heading-anchor" href="#Per-thread-allocation:-another-good-way-(Channel)">Per-thread allocation: another good way (<code>Channel</code>)</a><a id="Per-thread-allocation:-another-good-way-(Channel)-1"></a><a class="docs-heading-anchor-permalink" href="#Per-thread-allocation:-another-good-way-(Channel)" title="Permalink"></a></h2><p>Above, we chose to put a limited number of buffers (e.g. <code>nthreads()</code>) into the channel and then spawn many tasks (one per input element). Sometimes it can make sense to flip things around and put the (many) input elements into a channel and only spawn a limited number of tasks (e.g. <code>nthreads()</code>) with a task-local buffer.</p><pre><code class="language-julia hljs">using OhMyThreads: tmapreduce
function matmulsums_perthread_channel_flipped(As, Bs; ntasks = nthreads())
    N = size(first(As), 1)
    chnl = Channel() do chnl
        for i in 1:length(As)
            put!(chnl, i)
        end
    end
    tmapreduce(vcat, 1:ntasks; scheduler = DynamicScheduler(; nchunks = 0)) do _ # we turn chunking off
        local C = Matrix{Float64}(undef, N, N)
        map(chnl) do i
            A = As[i]
            B = Bs[i]
            mul!(C, A, B)
            sum(C)
        end
    end
end</code></pre><pre><code class="nohighlight hljs">matmulsums_perthread_channel_flipped (generic function with 1 method)</code></pre><p>Note that one caveat of this approach is that the input ‚Üí task assignment, and thus the order of the output, is non-deterministic. For this reason, we sort the output to check for correctness.</p><pre><code class="language-julia hljs">res_channel_flipped = matmulsums_perthread_channel_flipped(As, Bs)
sort(res) ‚âà sort(res_channel_flipped)</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>Quick benchmark:</p><pre><code class="language-julia hljs">@btime matmulsums_perthread_channel_flipped($As, $Bs);
@btime matmulsums_perthread_channel_flipped($As, $Bs; ntasks = 10 * nthreads());</code></pre><pre><code class="nohighlight hljs">  842.831 ms (726 allocations: 322.54 MiB)
  878.080 ms (1758 allocations: 3.15 GiB)
</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../">¬´ OhMyThreads</a><a class="docs-footer-nextpage" href="../../../translation/">Translation Guide ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 27 February 2024 17:07">Tuesday 27 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
