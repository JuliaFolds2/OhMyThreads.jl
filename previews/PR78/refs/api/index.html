<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · OhMyThreads.jl</title><meta name="title" content="Public API · OhMyThreads.jl"/><meta property="og:title" content="Public API · OhMyThreads.jl"/><meta property="twitter:title" content="Public API · OhMyThreads.jl"/><meta name="description" content="Documentation for OhMyThreads.jl."/><meta property="og:description" content="Documentation for OhMyThreads.jl."/><meta property="twitter:description" content="Documentation for OhMyThreads.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OhMyThreads.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">OhMyThreads</a></li><li><a class="tocitem" href="../../translation/">Translation Guide</a></li><li><a class="tocitem" href="../../literate/tls/tls/">Thread-Safe Storage</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../literate/mc/mc/">Parallel Monte Carlo</a></li><li><a class="tocitem" href="../../literate/juliaset/juliaset/">Julia Set</a></li><li><a class="tocitem" href="../../literate/integration/integration/">Trapezoidal Integration</a></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Exported"><span>Exported</span></a></li><li><a class="tocitem" href="#Non-Exported"><span>Non-Exported</span></a></li></ul></li><li><a class="tocitem" href="../internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaFolds2/OhMyThreads.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/master/docs/src/refs/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">Public API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Exported"><a class="docs-heading-anchor" href="#Exported">Exported</a><a id="Exported-1"></a><a class="docs-heading-anchor-permalink" href="#Exported" title="Permalink"></a></h2><h3 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@tasks" href="#OhMyThreads.@tasks"><code>OhMyThreads.@tasks</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@tasks for ... end</code></pre><p>A macro to parallelize a <code>for</code> loop by spawning a set of tasks that can be run in parallel. The policy of how many tasks to spawn and how to distribute the iteration space among the tasks (and more) can be configured via <code>@set</code> statements in the loop body.</p><p>Supports reductions (<code>@set reducer=&lt;reducer function&gt;</code>) and collecting the results (<code>@set collect=true</code>).</p><p>Under the hood, the <code>for</code> loop is translated into corresponding parallel <a href="#OhMyThreads.tforeach"><code>tforeach</code></a>, <a href="#OhMyThreads.tmapreduce"><code>tmapreduce</code></a>, or <a href="#OhMyThreads.tmap"><code>tmap</code></a> calls.</p><p>See also: <a href="#OhMyThreads.@set"><code>@set</code></a>, <a href="#OhMyThreads.@local"><code>@local</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@tasks for i in 1:3
    println(i)
end</code></pre><pre><code class="language-julia hljs">@tasks for x in rand(10)
    @set reducer=+
    sin(x)
end</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:5
    @set collect=true
    i^2
end</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:5
    @set scheduler=:static
    println(&quot;i=&quot;, i, &quot; → &quot;, threadid())
end
</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:100
    @set scheduler=DynamicScheduler(; nchunks=4*nthreads())
    # non-uniform work...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/macros.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@set" href="#OhMyThreads.@set"><code>OhMyThreads.@set</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@set name = value</code></pre><p>This can be used inside a <code>@tasks for ... end</code> block to specify settings for the parallel execution of the loop.</p><p>Multiple settings are supported, either as separate <code>@set</code> statements or via <code>@set begin ... end</code>.</p><p><strong>Settings</strong></p><ul><li><code>scheduler</code> (e.g. <code>scheduler=:static</code>): Can be either a <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> or a <code>Symbol</code> (e.g. <code>:dynamic</code> or <code>:static</code>)</li><li><code>reducer</code> (e.g. <code>reducer=+</code>): Indicates that a reduction should be performed with the provided binary function. See <a href="#OhMyThreads.tmapreduce"><code>tmapreduce</code></a> for more information.</li><li><code>collect</code> (e.g. <code>collect=true</code>): Indicates that results should be collected (similar to <code>map</code>).</li><li><code>init</code> (e.g. <code>init=0.0</code>): Initial value to be used in a reduction (requires <code>reducer=...</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/macros.jl#L56-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.@local" href="#OhMyThreads.@local"><code>OhMyThreads.@local</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@local name = value

@local name::T = value</code></pre><p>Can be used inside a <code>@tasks for ... end</code> block to specify <a href="../../literate/tls/tls/#TLS">task-local values</a> (TLV) via explicitly typed assignments. These values will be allocated once per task (rather than once per iteration) and can be re-used between different task-local iterations.</p><p>There can only be a single <code>@local</code> block in a <code>@tasks for ... end</code> block. To specify multiple TLVs, use <code>@local begin ... end</code>. Compared to regular assignments, there are some limitations though, e.g. TLVs can&#39;t reference each other.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using OhMyThreads.Tools: taskid
@tasks for i in 1:10
    @set scheduler=DynamicScheduler(; nchunks=2)
    @local x = zeros(3) # TLV

    x .+= 1
    println(taskid(), &quot; -&gt; &quot;, x)
end</code></pre><pre><code class="language-julia hljs">@tasks for i in 1:10
    @local begin
        x = rand(Int, 3)
        M = rand(3, 3)
    end
    # ...
end</code></pre><p>Task local variables created by <code>@local</code> are by default constrained to their inferred type, but if you need to, you can specify a different type during declaration:</p><pre><code class="language-julia hljs">@tasks for i in 1:10
    @local x::Vector{Float64} = some_hard_to_infer_setup_function()
    # ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/macros.jl#L77-L122">source</a></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tmapreduce" href="#OhMyThreads.tmapreduce"><code>OhMyThreads.tmapreduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tmapreduce(f, op, A::AbstractArray...;
           [scheduler::Scheduler = DynamicScheduler()],
           [outputtype::Type = Any],
           [init])</code></pre><p>A multithreaded function like <code>Base.mapreduce</code>. Perform a reduction over <code>A</code>, applying a single-argument function <code>f</code> to each element, and then combining them with the two-argument function <code>op</code>.</p><p>Note that <code>op</code> <strong>must</strong> be an <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> function, in the sense that <code>op(a, op(b, c)) ≈ op(op(a, b), c)</code>. If <code>op</code> is not (approximately) associative, you will get undefined results.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">tmapreduce(√, +, [1, 2, 3, 4, 5])</code></pre><p>is the parallelized version of <code>sum(√, [1, 2, 3, 4, 5])</code> in the form</p><pre><code class="nohighlight hljs">(√1 + √2) + (√3 + √4) + √5</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Scheduler</code> (default <code>DynamicScheduler()</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information.</li><li><code>outputtype::Type</code> (default <code>Any</code>): will work as the asserted output type of parallel calculations. We use <a href="https://github.com/MasonProtter/StableTasks.jl">StableTasks.jl</a> to make setting this option unnecessary, but if you experience problems with type stability, you may be able to recover it with this keyword argument.</li><li><code>init</code>: forwarded to <code>mapreduce</code> for the task-local sequential parts of the calculation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/functions.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.treduce" href="#OhMyThreads.treduce"><code>OhMyThreads.treduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">treduce(op, A::AbstractArray...;
        [scheduler::Scheduler = DynamicScheduler()],
        [outputtype::Type = Any],
        [init])</code></pre><p>A multithreaded function like <code>Base.reduce</code>. Perform a reduction over <code>A</code> using the two-argument function <code>op</code>.</p><p>Note that <code>op</code> <strong>must</strong> be an <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> function, in the sense that <code>op(a, op(b, c)) ≈ op(op(a, b), c)</code>. If <code>op</code> is not (approximately) associative, you will get undefined results.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">treduce(+, [1, 2, 3, 4, 5])</code></pre><p>is the parallelized version of <code>sum([1, 2, 3, 4, 5])</code> in the form</p><pre><code class="nohighlight hljs">(1 + 2) + (3 + 4) + 5</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Scheduler</code> (default <code>DynamicScheduler()</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information.</li><li><code>outputtype::Type</code> (default <code>Any</code>): will work as the asserted output type of parallel calculations. We use <a href="https://github.com/MasonProtter/StableTasks.jl">StableTasks.jl</a> to make setting this option unnecessary, but if you experience problems with type stability, you may be able to recover it with this keyword argument.</li><li><code>init</code>: forwarded to <code>mapreduce</code> for the task-local sequential parts of the calculation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/functions.jl#L72-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tmap" href="#OhMyThreads.tmap"><code>OhMyThreads.tmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tmap(f, [OutputElementType], A::AbstractArray...;
     [schedule::Scheduler = DynamicScheduler()])</code></pre><p>A multithreaded function like <code>Base.map</code>. Create a new container <code>similar</code> to <code>A</code> and fills it in parallel such that the <code>i</code>th element is equal to <code>f(A[i])</code>.</p><p>The optional argument <code>OutputElementType</code> will select a specific element type for the returned container, and will generally incur fewer allocations than the version where <code>OutputElementType</code> is not specified.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">tmap(sin, 1:10)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Scheduler</code> (default <code>DynamicScheduler()</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/functions.jl#L133-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tmap!" href="#OhMyThreads.tmap!"><code>OhMyThreads.tmap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tmap!(f, out, A::AbstractArray...;
      [schedule::Scheduler = DynamicScheduler()])</code></pre><p>A multithreaded function like <code>Base.map!</code>. In parallel on multiple tasks, this function assigns each element of <code>out[i] = f(A[i])</code> for each index <code>i</code> of <code>A</code> and <code>out</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Scheduler</code> (default <code>DynamicScheduler()</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/functions.jl#L156-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tforeach" href="#OhMyThreads.tforeach"><code>OhMyThreads.tforeach</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tforeach(f, A::AbstractArray...;
         [schedule::Scheduler = DynamicScheduler()]) :: Nothing</code></pre><p>A multithreaded function like <code>Base.foreach</code>. Apply <code>f</code> to each element of <code>A</code> on multiple parallel tasks, and return <code>nothing</code>. I.e. it is the parallel equivalent of</p><pre><code class="nohighlight hljs">for x in A
    f(x)
end</code></pre><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">tforeach(1:10) do i
    println(i^2)
end</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Scheduler</code> (default <code>DynamicScheduler()</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/functions.jl#L106-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.tcollect" href="#OhMyThreads.tcollect"><code>OhMyThreads.tcollect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tcollect([OutputElementType], gen::Union{AbstractArray, Generator{&lt;:AbstractArray}};
         [schedule::Scheduler = DynamicScheduler()])</code></pre><p>A multithreaded function like <code>Base.collect</code>. Essentially just calls <code>tmap</code> on the generator function and inputs.</p><p>The optional argument <code>OutputElementType</code> will select a specific element type for the returned container, and will generally incur fewer allocations than the version where <code>OutputElementType</code> is not specified.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">tcollect(sin(i) for i in 1:10)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Scheduler</code> (default <code>DynamicScheduler()</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/functions.jl#L169-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.treducemap" href="#OhMyThreads.treducemap"><code>OhMyThreads.treducemap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">treducemap(op, f, A::AbstractArray...;
           [scheduler::Scheduler = DynamicScheduler()],
           [outputtype::Type = Any],
           [init])</code></pre><p>Like <code>tmapreduce</code> except the order of the <code>f</code> and <code>op</code> arguments are switched. This is sometimes convenient with <code>do</code>-block notation. Perform a reduction over <code>A</code>, applying a single-argument function <code>f</code> to each element, and then combining them with the two-argument function <code>op</code>.</p><p>Note that <code>op</code> <strong>must</strong> be an <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> function, in the sense that <code>op(a, op(b, c)) ≈ op(op(a, b), c)</code>. If <code>op</code> is not (approximately) associative, you will get undefined results.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">tmapreduce(√, +, [1, 2, 3, 4, 5])</code></pre><p>is the parallelized version of <code>sum(√, [1, 2, 3, 4, 5])</code> in the form</p><pre><code class="nohighlight hljs">(√1 + √2) + (√3 + √4) + √5</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>scheduler::Scheduler</code> (default <code>DynamicScheduler()</code>): determines how the computation is divided into parallel tasks and how these are scheduled. See <a href="#OhMyThreads.Schedulers.Scheduler"><code>Scheduler</code></a> for more information.</li><li><code>outputtype::Type</code> (default <code>Any</code>): will work as the asserted output type of parallel calculations. We use <a href="https://github.com/MasonProtter/StableTasks.jl">StableTasks.jl</a> to make setting this option unnecessary, but if you experience problems with type stability, you may be able to recover it with this keyword argument.</li><li><code>init</code>: forwarded to <code>mapreduce</code> for the task-local sequential parts of the calculation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/functions.jl#L36-L69">source</a></section></article><h3 id="Schedulers"><a class="docs-heading-anchor" href="#Schedulers">Schedulers</a><a id="Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Schedulers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.Scheduler" href="#OhMyThreads.Schedulers.Scheduler"><code>OhMyThreads.Schedulers.Scheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all available schedulers:</p><ul><li><a href="#OhMyThreads.Schedulers.DynamicScheduler"><code>DynamicScheduler</code></a>: default dynamic scheduler</li><li><a href="#OhMyThreads.Schedulers.StaticScheduler"><code>StaticScheduler</code></a>: low-overhead static scheduler</li><li><a href="#OhMyThreads.Schedulers.GreedyScheduler"><code>GreedyScheduler</code></a>: greedy load-balancing scheduler</li><li><a href="#OhMyThreads.Schedulers.SerialScheduler"><code>SerialScheduler</code></a>: serial (non-parallel) execution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/schedulers.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.DynamicScheduler" href="#OhMyThreads.Schedulers.DynamicScheduler"><code>OhMyThreads.Schedulers.DynamicScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The default dynamic scheduler. Divides the given collection into chunks and then spawns a task per chunk to perform the requested operation in parallel. The tasks are assigned to threads by Julia&#39;s dynamic scheduler and are non-sticky, that is, they can migrate between threads.</p><p>Generally preferred since it is flexible, can provide load balancing, and is composable with other multithreaded code.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>nchunks::Integer</code> (default <code>2 * nthreads(threadpool)</code>):<ul><li>Determines the number of chunks (and thus also the number of parallel tasks).</li><li>Increasing <code>nchunks</code> can help with <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">load balancing</a>, but at the expense of creating more overhead. For <code>nchunks &lt;= nthreads()</code> there are not enough chunks for any load balancing.</li><li>Setting <code>nchunks &lt; nthreads()</code> is an effective way to use only a subset of the available threads.</li></ul></li><li><code>chunksize::Integer</code> (default not set)<ul><li>Specifies the desired chunk size (instead of the number of chunks).</li><li>The options <code>chunksize</code> and <code>nchunks</code> are <strong>mutually exclusive</strong> (only one may be a positive integer).</li></ul></li><li><code>split::Symbol</code> (default <code>:batch</code>):<ul><li>Determines how the collection is divided into chunks (if chunking=true). By default, each chunk consists of contiguous elements and order is maintained.</li><li>See <a href="https://github.com/JuliaFolds2/ChunkSplitters.jl">ChunkSplitters.jl</a> for more details and available options.</li><li>Beware that for <code>split=:scatter</code> the order of elements isn&#39;t maintained and a reducer function must not only be associative but also <strong>commutative</strong>!</li></ul></li><li><code>chunking::Bool</code> (default <code>true</code>):<ul><li>Controls whether input elements are grouped into chunks (<code>true</code>) or not (<code>false</code>).</li><li>For <code>chunking=false</code>, the arguments <code>nchunks</code>, <code>chunksize</code>, and <code>split</code> are ignored and input elements are regarded as &quot;chunks&quot; as is. Hence, there will be one parallel task spawned per input element. Note that, depending on the input, this <strong>might spawn many(!) tasks</strong> and can be costly!</li></ul></li><li><code>threadpool::Symbol</code> (default <code>:default</code>):<ul><li>Possible options are <code>:default</code> and <code>:interactive</code>.</li><li>The high-priority pool <code>:interactive</code> should be used very carefully since tasks on this threadpool should not be allowed to run for a long time without <code>yield</code>ing as it can interfere with <a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">heartbeat</a> processes.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/schedulers.jl#L31-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.StaticScheduler" href="#OhMyThreads.Schedulers.StaticScheduler"><code>OhMyThreads.Schedulers.StaticScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A static low-overhead scheduler. Divides the given collection into chunks and then spawns a task per chunk to perform the requested operation in parallel. The tasks are statically assigned to threads up front and are made <em>sticky</em>, that is, they are guaranteed to stay on the assigned threads (<strong>no task migration</strong>).</p><p>Can sometimes be more performant than <code>DynamicScheduler</code> when the workload is (close to) uniform and, because of the lower overhead, for small workloads. Isn&#39;t well composable with other multithreaded code though.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>nchunks::Integer</code> (default <code>nthreads()</code>):<ul><li>Determines the number of chunks (and thus also the number of parallel tasks).</li><li>Setting <code>nchunks &lt; nthreads()</code> is an effective way to use only a subset of the available threads.</li><li>For <code>nchunks &gt; nthreads()</code> the chunks will be distributed to the available threads in a round-robin fashion.</li></ul></li><li><code>chunksize::Integer</code> (default not set)<ul><li>Specifies the desired chunk size (instead of the number of chunks).</li><li>The options <code>chunksize</code> and <code>nchunks</code> are <strong>mutually exclusive</strong> (only one may be non-zero).</li></ul></li><li><code>chunking::Bool</code> (default <code>true</code>):<ul><li>Controls whether input elements are grouped into chunks (<code>true</code>) or not (<code>false</code>).</li><li>For <code>chunking=false</code>, the arguments <code>nchunks</code>, <code>chunksize</code>, and <code>split</code> are ignored and input elements are regarded as &quot;chunks&quot; as is. Hence, there will be one parallel task spawned per input element. Note that, depending on the input, this <strong>might spawn many(!) tasks</strong> and can be costly!</li></ul></li><li><code>split::Symbol</code> (default <code>:batch</code>):<ul><li>Determines how the collection is divided into chunks. By default, each chunk consists of contiguous elements and order is maintained.</li><li>See <a href="https://github.com/JuliaFolds2/ChunkSplitters.jl">ChunkSplitters.jl</a> for more details and available options.</li><li>Beware that for <code>split=:scatter</code> the order of elements isn&#39;t maintained and a reducer function must not only be associative but also <strong>commutative</strong>!</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/schedulers.jl#L115-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.GreedyScheduler" href="#OhMyThreads.Schedulers.GreedyScheduler"><code>OhMyThreads.Schedulers.GreedyScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A greedy dynamic scheduler. The elements of the collection are first put into a <code>Channel</code> and then dynamic, non-sticky tasks are spawned to process channel content in parallel.</p><p>Note that elements are processed in a non-deterministic order, and thus a potential reducing function <strong>must</strong> be <a href="https://en.wikipedia.org/wiki/Commutative_property">commutative</a> in addition to being associative, or you could get incorrect results!</p><p>Can be good choice for load-balancing slower, uneven computations, but does carry some additional overhead.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>ntasks::Int</code> (default <code>nthreads()</code>):<ul><li>Determines the number of parallel tasks to be spawned.</li><li>Setting <code>nchunks &lt; nthreads()</code> is an effective way to use only a subset of the available threads.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/schedulers.jl#L192-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.Schedulers.SerialScheduler" href="#OhMyThreads.Schedulers.SerialScheduler"><code>OhMyThreads.Schedulers.SerialScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A scheduler for turning off any multithreading and running the code in serial. It aims to make parallel functions like, e.g., <code>tmapreduce(sin, +, 1:100)</code> behave like their serial counterparts, e.g., <code>mapreduce(sin, +, 1:100)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/schedulers.jl#L224-L228">source</a></section></article><h2 id="Non-Exported"><a class="docs-heading-anchor" href="#Non-Exported">Non-Exported</a><a id="Non-Exported-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Exported" title="Permalink"></a></h2><table><tr><th style="text-align: right"></th><th style="text-align: right"></th></tr><tr><td style="text-align: right"><code>OhMyThreads.@spawn</code></td><td style="text-align: right">see <a href="https://github.com/JuliaFolds2/StableTasks.jl">StableTasks.jl</a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.@spawnat</code></td><td style="text-align: right">see <a href="https://github.com/JuliaFolds2/StableTasks.jl">StableTasks.jl</a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.@fetch</code></td><td style="text-align: right">see <a href="https://github.com/JuliaFolds2/StableTasks.jl">StableTasks.jl</a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.@fetchfrom</code></td><td style="text-align: right">see <a href="https://github.com/JuliaFolds2/StableTasks.jl">StableTasks.jl</a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.chunks</code></td><td style="text-align: right">see <a href="https://juliafolds2.github.io/ChunkSplitters.jl/dev/references/#ChunkSplitters.chunks">ChunkSplitters.jl</a></td></tr><tr><td style="text-align: right"><code>OhMyThreads.TaskLocalValue</code></td><td style="text-align: right">see <a href="https://github.com/vchuravy/TaskLocalValues.jl">TaskLocalValues.jl</a></td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.WithTaskLocals" href="#OhMyThreads.WithTaskLocals"><code>OhMyThreads.WithTaskLocals</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct WithTaskLocals{F, TLVs &lt;: Tuple{Vararg{TaskLocalValue}}} &lt;: Function</code></pre><p>This callable function-like object is meant to represent a function which closes over some <a href="https://github.com/vchuravy/TaskLocalValues.jl"><code>TaskLocalValues</code></a>. This is, if you do</p><pre><code class="nohighlight hljs">TLV{T} = TaskLocalValue{T}
f = WithTaskLocals((TLV{Int}(() -&gt; 1), TLV{Int}(() -&gt; 2))) do (x, y)
    z -&gt; (x + y)/z
end</code></pre><p>then that is equivalent to</p><pre><code class="nohighlight hljs">g = let x = TLV{Int}(() -&gt; 1), y = TLV{Int}(() -&gt; 2)
    z -&gt; let x = x[], y=y[]
        (x + y)/z
    end
end</code></pre><p>however, the main difference is that you can call <a href="#OhMyThreads.promise_task_local"><code>promise_task_local</code></a> on a <code>WithTaskLocals</code> closure in order to turn it into something equivalent to</p><pre><code class="nohighlight hljs">let x=x[], y=y[]
    z -&gt; (x + y)/z
end</code></pre><p>which doesn&#39;t have the overhead of accessing the <code>task_local_storage</code> each time the closure is called. This of course will lose the safety advantages of <code>TaskLocalValue</code>, so you should never do <code>f_local = promise_task_local(f)</code> and then pass <code>f_local</code> to some unknown function, because if that unknown function calls <code>f_local</code> on a new task, you&#39;ll hit a race condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/types.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OhMyThreads.promise_task_local" href="#OhMyThreads.promise_task_local"><code>OhMyThreads.promise_task_local</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">promise_task_local(f) = f
promise_task_local(f::WithTaskLocals) = f.inner_func(map(x -&gt; x[], f.tasklocals))</code></pre><p>Take a <code>WithTaskLocals</code> closure, grab the <code>TaskLocalValue</code>s, and passs them to the closure. That is, it turns a <code>WithTaskLocals</code> closure from the equivalent of</p><pre><code class="nohighlight hljs">TLV{T} = TaskLocalValue{T}
let x = TLV{Int}(() -&gt; 1), y = TLV{Int}(() -&gt; 2)
    z -&gt; let x = x[], y=y[]
        (x + y)/z
    end
end</code></pre><p>into the equivalent of</p><pre><code class="nohighlight hljs">let x = TLV{Int}(() -&gt; 1), y = TLV{Int}(() -&gt; 2)
    let x = x[], y = y[]
        z -&gt; (x + y)/z
    end
end</code></pre><p>which doesn&#39;t have the overhead of accessing the <code>task_local_storage</code> each time the closure is called. This of course will lose the safety advantages of <code>TaskLocalValue</code>, so you should never do <code>f_local = promise_task_local(f)</code> and then pass <code>f_local</code> to some unknown function, because if that unknown function calls <code>f_local</code> on a new task, you&#39;ll hit a race condition.  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFolds2/OhMyThreads.jl/blob/125bb477d388bc0837f2c374b8556043f8497f1c/src/types.jl#L38-L65">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../literate/integration/integration/">« Trapezoidal Integration</a><a class="docs-footer-nextpage" href="../internal/">Internal »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 12 March 2024 12:31">Tuesday 12 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
